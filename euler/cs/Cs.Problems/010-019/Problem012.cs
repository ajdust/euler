// Author: Aaron Johnson
// Date: 2015-02-10
// 
// Solves Euler Problem 12.

using System.Collections.Generic;
using System.Linq;

namespace Cs.Problems
{
    /// <title>Highly divisible triangular number</title>
    /// <summary>
    /// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    ///
    /// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    ///
    /// Let us list the factors of the first seven triangle numbers:
    ///
    /// 1: 1
    /// 3: 1,3
    /// 6: 1,2,3,6
    /// 10: 1,2,5,10
    /// 15: 1,3,5,15
    /// 21: 1,3,7,21
    /// 28: 1,2,4,7,14,28
    ///
    /// We can see that 28 is the first triangle number to have over five divisors.
    ///
    /// What is the value of the first triangle number to have over five hundred divisors?
    ///
    /// </summary>
    /// <remarks>This problem builds off of Problem 3.</remarks>
    /// <answer>76576500</answer>
    public class Problem012 : IProblem
    {
        private static readonly Dictionary<long, HashSet<long>> FactorsDictionary = new Dictionary<long, HashSet<long>>();

        public Problem012()
        {
            FactorsDictionary[1] = new HashSet<long> { 1 };
        }

        public static HashSet<long> GetFactors(long n)
        {
            if (FactorsDictionary.ContainsKey(n))
            {
                return FactorsDictionary[n];
            }

            // initialize the factor list to the prime factors and 1 and n
            var primeFactors = Sequences.GetPrimeFactors(n);
            var factorSet = new HashSet<long>(primeFactors) { 1, n };

            // divide by primes and recursively determine the factors to be aggregated
            foreach (var prime in primeFactors)
            {
                var factor = n / prime;
                if (factor <= 2 || factorSet.Contains(factor))
                    continue;
                foreach (var subfactor in GetFactors(factor))
                    factorSet.Add(subfactor);
            }

            FactorsDictionary[n] = factorSet;
            return factorSet;
        }
        public string Solve()
        {
            return Sequences.TriangleNumbers().First(t => GetFactors(t).Count > 500).ToString();
        }
    }
}
