(* Aaron Johnson
   2017-03-26 *)

open Batteries


(*
 * Problem 1: Multiples of 3 and 5
 * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6
 * and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5
 * below 1000.
 *)
let problem01 () = List.of_enum (1--^1000)
    |> List.filter (fun x -> x mod 3 == 0 || x mod 5 == 0 || x mod 15 == 0)
    |> List.sum
    |> string_of_int


(*
 * Problem 2: Even Fibonacci Numbers
 * Each new term in the Fibonacci sequence is generated by adding
 * the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values do not exceed
 * four million, find the sum of the even-valued terms.
 *)
let next_fib (a, b) = (b, a + b)
let fibs =
    let fib_pairs = LazyList.seq (0, 1) next_fib (fun _ -> true) in
    LazyList.map (fun (a, b) -> a) fib_pairs

let problem02 () = fibs
    |> LazyList.take_while (fun x -> x < 4000000)
    |> LazyList.filter (fun x -> x mod 2 == 0)
    |> LazyList.fold_right (+) 0
    |> string_of_int


(*
 * Problem 3: Largest prime factor
 * The prime factors of 13195 are 5, 7, 13 and 29.
 * What is the largest prime factor of the number 600851475143 ?
 *)
let rec add_next_composite n prime sieve =
    let open Int64 in
    match Map.mem n sieve with
    | true -> add_next_composite (n + prime + prime) prime sieve
    | false -> Map.add n prime sieve

type primes_iter = {
    n : int64 ;
    last : int64 ;
    sieve : (int64, int64) BatMap.t
}

let start_prime_iter = {
    n = 3L ;
    last = 2L ;
    sieve = Map.empty
}

let rec next_prime n sieve =
    let open Int64 in
    try let prime = Map.find n sieve in
        let gc = Map.remove n sieve in
        let ac = add_next_composite (n + prime + prime) prime gc in
        next_prime (n + 2L) ac
    with
        Not_found -> { n = n + 2L ; last = n ; sieve = Map.add (n*n) n sieve }

let next_prime_iter iter = next_prime iter.n iter.sieve

let primes =
    let open LazyList in
    let prime_iters = seq start_prime_iter next_prime_iter (fun _ -> true) in
    map (fun primeIter -> primeIter.last) prime_iters

let prime_factors n =
    let open LazyList in
    let open Int64 in
    let rec pfactors primes n = match get primes with
        | None -> raise Not_found
        | Some((prime, next_primes)) ->
            if prime >= n then [prime]
            else if rem n prime = 0L then prime :: (pfactors primes (n / prime))
            else pfactors next_primes n
    in pfactors primes n

let problem03 () = prime_factors 600851475143L |> List.max |> Printf.sprintf "%Li"


(*
 * Problem 4: Largest palindromic product
 * A palindromic number reads the same both ways. The largest palindrome
 * made from the product of two 2-digit numbers is 9009 = 91 × 99.
 * Find the largest palindrome made from the product of two 3-digit numbers.
*)
let is_palindrome s =
    let open String in
    let full_len = length s in
    let half_len = full_len / 2 in
    let open List in
    let check = map (fun i -> s.[i] = s.[full_len - 1 - i]) (of_enum(0 -- half_len)) in
    not (exists ((=)false) check)

let three_digit_combos () =
    let open List in
    let three_digits = of_enum(100--999) in
    flatten (map (fun i -> map (fun si -> (i, si)) (of_enum(i--999))) three_digits)

let problem04 () =
    let open List in
    map (fun (a, b) -> a * b) (three_digit_combos ())
    |> filter (fun n -> is_palindrome (string_of_int n))
    |> max
    |> string_of_int


(*
 * Problem 5: Smallest multiple
 * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10
 * without any remainder. What is the smallest positive number that is evenly divisible
 * by all of the numbers from 1 to 20?
 *)
let count_distinct elements =
    let f = (fun m element ->
        try
            Map.add element ((Map.find element m) + 1) m
        with
            Not_found -> Map.add element 1 m) in
    List.fold_left f (Map.empty : (int64, int) BatMap.t) elements

let merge_counts counts =
    let open Map in
    let f = (fun m (el, count) ->
        try
            add el (max (find el m) count) m
        with
            Not_found -> add el count m) in
    List.fold_left f (Map.empty : (int64, int) BatMap.t) counts

let map_to_list map =
    Enum.fold (fun c a -> List.cons a c) [] (Map.enum map)

let pow64 i64 i32 = Int64.pow i64 (Int64.of_int i32)

let one_to_twenty_merged_pf () =
    let open Int64 in
    let open List in
    [2L;3L;4L;5L;6L;7L;8L;9L;10L;11L;12L;13L;14L;15L;16L;17L;18L;19L;20L]
    |> map prime_factors
    |> map count_distinct
    |> map map_to_list
    |> concat
    |> merge_counts
    |> map_to_list
    |> fold_left (fun c (a, b) -> c * pow64 a b) 1L

let problem05 () = one_to_twenty_merged_pf () |> Printf.sprintf "%Li"


(*
 * Problem 6: Sum square difference
 *
 * The sum of the squares of the first ten natural numbers is,
 * 12 + 22 + ... + 102 = 385
 * The square of the sum of the first ten natural numbers is,
 * (1 + 2 + ... + 10)2 = 552 = 3025
 * Hence the difference between the sum of the squares of the first ten natural numbers
 * and the square of the sum is 3025 − 385 = 2640.
 *
 * Find the difference between the sum of the squares of the first one hundred natural
 * numbers and the square of the sum.
 *)
let problem06 () =
    let open Enum in
    let open Int in
    let square_sums = pow (of_enum(1--100) |> sum) 2 in
    let sum_squares = of_enum(1--100) |> map (fun x -> pow x 2) |> sum in
    string_of_int (abs (sum_squares - square_sums))


(*
 * Problem 7: 10001st prime
 *
 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
 * we can see that the 6th prime is 13. What is the 10001st prime number?
 *)
let problem07 () =
    let prime = LazyList.at primes 10000 in
    Printf.sprintf "%Li" prime


(*
 * Problem 8: Largest product in a series
 *
 * The four adjacent digits in the 1000-digit number that have the greatest
 * product are 9 × 9 × 8 × 9 = 5832.
 *
 * 73167176531330624919225119674426574742355349194934
 * 96983520312774506326239578318016984801869478851843
 * 85861560789112949495459501737958331952853208805511
 * 12540698747158523863050715693290963295227443043557
 * 66896648950445244523161731856403098711121722383113
 * 62229893423380308135336276614282806444486645238749
 * 30358907296290491560440772390713810515859307960866
 * 70172427121883998797908792274921901699720888093776
 * 65727333001053367881220235421809751254540594752243
 * 52584907711670556013604839586446706324415722155397
 * 53697817977846174064955149290862569321978468622482
 * 83972241375657056057490261407972968652414535100474
 * 82166370484403199890008895243450658541227588666881
 * 16427171479924442928230863465674813919123162824586
 * 17866458359124566529476545682848912883142607690042
 * 24219022671055626321111109370544217506941658960408
 * 07198403850962455444362981230987879927244284909188
 * 84580156166097919133875499200524063689912560717606
 * 05886116467109405077541002256983155200055935729725
 * 71636269561882670428252483600823257530420752963450
 *
 * Find the thirteen adjacent digits in the 1000-digit number that have the
 * greatest product. What is the value of this product?
 *)
let p8_raw = "
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450"

let parse_digit i = match i with
    | '0' -> Some 0
    | '1' -> Some 1
    | '2' -> Some 2
    | '3' -> Some 3
    | '4' -> Some 4
    | '5' -> Some 5
    | '6' -> Some 6
    | '7' -> Some 7
    | '8' -> Some 8
    | '9' -> Some 9
    | _ -> None

let p8_digits =
    let open String in
    List.map parse_digit (to_list p8_raw)
    |> List.filter Option.is_some
    |> List.map Option.get
    |> List.map Int64.of_int

let problem08 () =
    let open List in
    let product es = List.reduce Int64.mul es in
    let thirteen = mapi (fun i _ ->  product (take 13 (drop i p8_digits ))) p8_digits in
    Printf.sprintf "%Li" (max thirteen)


(*
 * Problem 9: Special Pythagorean triplet
 *
 *
 * A Pythagorean triplet is a set of three natural numbers, a LT b LT c, for which,
 * a^2 + b^2 = c^2
 *
 * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
 *
 * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
 * Find the product a*b*c.
 *)
let problem09 () =
    let answer = ref 0 in
        for c = 1 to 1000 do
            for b = 1 to c do
                for a = 1 to b do
                    if a*a + b*b = c*c && a + b + c = 1000 then answer := a * b * c
                done
            done
        done;
    string_of_int (!answer)


(*
 * Problem 10: Summation of primes
 *
 * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
 * Find the sum of all the primes below two million.
 *)
 let problem10 () =
    let open LazyList in
    take_while (fun x -> x < 2000000L) primes
    |> fold_left Int64.add 0L
    |> Printf.sprintf "%Li"

(* solve = toInteger $ sum (takeWhile (<2000000) primes) *)


(*
 * Problem 11: Largest product in a grid
 * In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
 *
 * 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
 * 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
 * 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
 * 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
 * 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
 * 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
 * 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
 * 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
 * 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
 * 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
 * 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
 * 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
 * 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
 * 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
 * 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
 * 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
 * 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
 * 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
 * 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
 * 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
 *
 * The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
 *
 * What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
 *)
let problem11 () =
    let grid = [| [| 08;02;22;97;38;15;00;40;00;75;04;05;07;78;52;12;50;77;91;08 |];
                  [| 49;49;99;40;17;81;18;57;60;87;17;40;98;43;69;48;04;56;62;00 |];
                  [| 81;49;31;73;55;79;14;29;93;71;40;67;53;88;30;03;49;13;36;65 |];
                  [| 52;70;95;23;04;60;11;42;69;24;68;56;01;32;56;71;37;02;36;91 |];
                  [| 22;31;16;71;51;67;63;89;41;92;36;54;22;40;40;28;66;33;13;80 |];
                  [| 24;47;32;60;99;03;45;02;44;75;33;53;78;36;84;20;35;17;12;50 |];
                  [| 32;98;81;28;64;23;67;10;26;38;40;67;59;54;70;66;18;38;64;70 |];
                  [| 67;26;20;68;02;62;12;20;95;63;94;39;63;08;40;91;66;49;94;21 |];
                  [| 24;55;58;05;66;73;99;26;97;17;78;78;96;83;14;88;34;89;63;72 |];
                  [| 21;36;23;09;75;00;76;44;20;45;35;14;00;61;33;97;34;31;33;95 |];
                  [| 78;17;53;28;22;75;31;67;15;94;03;80;04;62;16;14;09;53;56;92 |];
                  [| 16;39;05;42;96;35;31;47;55;58;88;24;00;17;54;24;36;29;85;57 |];
                  [| 86;56;00;48;35;71;89;07;05;44;44;37;44;60;21;58;51;54;17;58 |];
                  [| 19;80;81;68;05;94;47;69;28;73;92;13;86;52;17;77;04;89;55;40 |];
                  [| 04;52;08;83;97;35;99;16;07;97;57;32;16;26;26;79;33;27;98;66 |];
                  [| 88;36;68;87;57;62;20;72;03;46;33;67;46;55;12;32;63;93;53;69 |];
                  [| 04;42;16;73;38;25;39;11;24;94;72;18;08;46;29;32;40;62;76;36 |];
                  [| 20;69;36;41;72;30;23;88;34;62;99;69;82;67;59;85;74;04;36;16 |];
                  [| 20;73;35;29;78;31;90;01;74;31;49;71;48;86;81;16;23;57;05;54 |];
                  [| 01;70;54;71;83;51;54;69;16;92;33;48;61;43;52;01;89;19;67;48 |]; |] in

    let atOrDefault g defaultValue x y =
        let height = 20 in
        let width = 20 in
        if y < height && y >= 0 && x < width && x >= 0
            then g.(y).(x)
            else defaultValue in
    
    let getLargestAdjacent g y x =
        let at = atOrDefault g 1 in
        let mult a b = a*b in
        let right = [at x y; at (x+1) y; at (x+2) y; at (x+3) y] |> List.reduce mult in
        let down = [at x y; at x (y+1); at x (y+2); at x (y+3)] |> List.reduce mult in
        let downright = [at x y; at (x+1) (y+1); at (x+2) (y+2); at (x+3) (y+3)] |> List.reduce mult in
        let downleft = [at x y; at (x-1) (y+1); at (x-2) (y+2); at (x-3) (y+3)] |> List.reduce mult in
        [ right; down; downright; downleft ] |> List.max in
    
    let answer = ref 0 in
        for x = 0 to 20 do
            for y = 0 to 20 do
                let largest = getLargestAdjacent grid x y in
                if largest > !answer then
                    answer := largest
            done
        done;
    Printf.sprintf "%i" !answer

(*
 * Problem 12: Highly divisible triangular number
 *
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 *
 *)
let next_triangle_number (n, tn) = let open Int64 in (n + 1L, tn + n)

let triangle_numbers =
    let tn_pairs = LazyList.seq (2L, 1L) next_triangle_number (fun _ -> true) in
    LazyList.map (fun (a, b) -> b) tn_pairs

let memoized_prime_factors = Hashtbl.create 1000000

let find_prime_factors n =
    try
        Hashtbl.find memoized_prime_factors n
    with Not_found ->
        let pfs = prime_factors n in
        Hashtbl.add memoized_prime_factors n pfs;
        pfs

let memoized_find_factors = Hashtbl.create 1000000

let rec find_factors n =
    try
        Hashtbl.find memoized_find_factors n
    with Not_found ->
        let fs = find_factors_ n in
        Hashtbl.add memoized_find_factors n fs;
        fs
and find_factors_ (n: int64) : int64 BatSet.t =
    let open Int64 in
    let pfs = find_prime_factors n in
    let factor_set = BatSet.union (BatSet.of_list [1L; n]) (BatSet.of_list pfs) in
    let open BatSet in
        LazyList.of_list pfs
        |> LazyList.map (fun prime -> n / prime)
        |> LazyList.filter (fun factor -> factor >= 2L && not (mem factor factor_set))
        |> LazyList.fold_left
           begin fun acc subfactor -> union acc (find_factors subfactor) end factor_set

let problem12 () =
    LazyList.find (fun tn -> BatSet.cardinal (find_factors tn) > 500) triangle_numbers
    |> Printf.sprintf "%Li"