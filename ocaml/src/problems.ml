(* Aaron Johnson
   2017-03-26 *)

open Batteries


(*
 * Problem 1: Multiples of 3 and 5
 * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6
 * and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5
 * below 1000.
 *)
let problem01 () = List.of_enum (1--^1000)
    |> List.filter (fun x -> x mod 3 == 0 || x mod 5 == 0 || x mod 15 == 0)
    |> List.sum
    |> string_of_int


(*
 * Problem 2: Even Fibonacci Numbers
 * Each new term in the Fibonacci sequence is generated by adding
 * the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values do not exceed
 * four million, find the sum of the even-valued terms.
 *)
let next_fib (a, b) = (b, a + b)
let fibs =
    let fib_pairs = LazyList.seq (0, 1) next_fib (fun _ -> true) in
    LazyList.map (fun (a, b) -> a) fib_pairs

let problem02 () = fibs
    |> LazyList.take_while (fun x -> x < 4000000)
    |> LazyList.filter (fun x -> x mod 2 == 0)
    |> LazyList.fold_right (+) 0
    |> string_of_int


(*
 * Problem 3: Largest prime factor
 * The prime factors of 13195 are 5, 7, 13 and 29.
 * What is the largest prime factor of the number 600851475143 ?
 *)
let rec add_next_composite n prime sieve =
    let open Int64 in
    match Map.mem n sieve with
    | true -> add_next_composite (n + prime + prime) prime sieve
    | false -> Map.add n prime sieve

type primes_iter = {
    n : int64 ;
    last : int64 ;
    sieve : (int64, int64) BatMap.t
}

let start_prime_iter = {
    n = 3L ;
    last = 2L ;
    sieve = Map.empty
}

let rec next_prime n sieve =
    let open Int64 in
    try let prime = Map.find n sieve in
        let gc = Map.remove n sieve in
        let ac = add_next_composite (n + prime + prime) prime gc in
        next_prime (n + 2L) ac
    with
        Not_found -> { n = n + 2L ; last = n ; sieve = Map.add (n*n) n sieve }

let next_prime_iter iter = next_prime iter.n iter.sieve

let primes =
    let open LazyList in
    let prime_iters = seq start_prime_iter next_prime_iter (fun _ -> true) in
    map (fun primeIter -> primeIter.last) prime_iters

let prime_factors n =
    let open LazyList in
    let open Int64 in
    let rec pfactors primes n = match get primes with
        | None -> raise Not_found
        | Some((prime, next_primes)) ->
            if prime >= n then [prime]
            else if rem n prime = 0L then prime :: (pfactors primes (n / prime))
            else pfactors next_primes n
    in pfactors primes n

let problem03 () = prime_factors 600851475143L |> List.max |> Printf.sprintf "%Li"


(*
 * Problem 4: Largest palindromic product
 * A palindromic number reads the same both ways. The largest palindrome
 * made from the product of two 2-digit numbers is 9009 = 91 × 99.
 * Find the largest palindrome made from the product of two 3-digit numbers.
*)
let is_palindrome s =
    let open String in
    let full_len = length s in
    let half_len = full_len / 2 in
    let open List in
    let check = map (fun i -> s.[i] = s.[full_len - 1 - i]) (of_enum(0 -- half_len)) in
    not (exists ((=)false) check)

let three_digit_combos () =
    let open List in
    let three_digits = of_enum(100--999) in
    flatten (map (fun i -> map (fun si -> (i, si)) (of_enum(i--999))) three_digits)

let problem04 () =
    let open List in
    map (fun (a, b) -> a * b) (three_digit_combos ())
    |> filter (fun n -> is_palindrome (string_of_int n))
    |> max
    |> string_of_int


(*
 * Problem 5: Smallest multiple
 * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10
 * without any remainder. What is the smallest positive number that is evenly divisible
 * by all of the numbers from 1 to 20?
 *)
let count_distinct elements =
    let f = (fun m element ->
        try
            Map.add element ((Map.find element m) + 1) m
        with
            Not_found -> Map.add element 1 m) in
    List.fold_left f (Map.empty : (int64, int) BatMap.t) elements

let merge_counts counts =
    let open Map in
    let f = (fun m (el, count) ->
        try
            add el (max (find el m) count) m
        with
            Not_found -> add el count m) in
    List.fold_left f (Map.empty : (int64, int) BatMap.t) counts

let map_to_list map =
    Enum.fold (fun c a -> List.cons a c) [] (Map.enum map)

let pow64 i64 i32 = Int64.pow i64 (Int64.of_int i32)

let one_to_twenty_merged_pf () =
    let open Int64 in
    let open List in
    [2L;3L;4L;5L;6L;7L;8L;9L;10L;11L;12L;13L;14L;15L;16L;17L;18L;19L;20L]
    |> map prime_factors
    |> map count_distinct
    |> map map_to_list
    |> concat
    |> merge_counts
    |> map_to_list
    |> fold_left (fun c (a, b) -> c * pow64 a b) 1L

let problem05 () = one_to_twenty_merged_pf () |> Printf.sprintf "%Li"


(*
 * Problem 6: Sum square difference
 *
 * The sum of the squares of the first ten natural numbers is,
 * 12 + 22 + ... + 102 = 385
 * The square of the sum of the first ten natural numbers is,
 * (1 + 2 + ... + 10)2 = 552 = 3025
 * Hence the difference between the sum of the squares of the first ten natural numbers
 * and the square of the sum is 3025 − 385 = 2640.
 *
 * Find the difference between the sum of the squares of the first one hundred natural
 * numbers and the square of the sum.
 *)
let problem06 () =
    let open Enum in
    let open Int in
    let square_sums = pow (of_enum(1--100) |> sum) 2 in
    let sum_squares = of_enum(1--100) |> map (fun x -> pow x 2) |> sum in
    string_of_int (abs (sum_squares - square_sums))


(*
 * Problem 7: 10001st prime
 *
 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
 * we can see that the 6th prime is 13. What is the 10001st prime number?
 *)
let problem07 () =
    let prime = LazyList.at primes 10000 in
    Printf.sprintf "%Li" prime


(*
 * Problem 8: Largest product in a series
 *
 * The four adjacent digits in the 1000-digit number that have the greatest
 * product are 9 × 9 × 8 × 9 = 5832.
 *
 * 73167176531330624919225119674426574742355349194934
 * 96983520312774506326239578318016984801869478851843
 * 85861560789112949495459501737958331952853208805511
 * 12540698747158523863050715693290963295227443043557
 * 66896648950445244523161731856403098711121722383113
 * 62229893423380308135336276614282806444486645238749
 * 30358907296290491560440772390713810515859307960866
 * 70172427121883998797908792274921901699720888093776
 * 65727333001053367881220235421809751254540594752243
 * 52584907711670556013604839586446706324415722155397
 * 53697817977846174064955149290862569321978468622482
 * 83972241375657056057490261407972968652414535100474
 * 82166370484403199890008895243450658541227588666881
 * 16427171479924442928230863465674813919123162824586
 * 17866458359124566529476545682848912883142607690042
 * 24219022671055626321111109370544217506941658960408
 * 07198403850962455444362981230987879927244284909188
 * 84580156166097919133875499200524063689912560717606
 * 05886116467109405077541002256983155200055935729725
 * 71636269561882670428252483600823257530420752963450
 *
 * Find the thirteen adjacent digits in the 1000-digit number that have the
 * greatest product. What is the value of this product?
 *)
let p8_raw = "
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450"

let parse_digit i = match i with
    | '0' -> Some 0
    | '1' -> Some 1
    | '2' -> Some 2
    | '3' -> Some 3
    | '4' -> Some 4
    | '5' -> Some 5
    | '6' -> Some 6
    | '7' -> Some 7
    | '8' -> Some 8
    | '9' -> Some 9
    | _ -> None

let p8_digits =
    let open String in
    List.map parse_digit (to_list p8_raw)
    |> List.filter Option.is_some
    |> List.map Option.get
    |> List.map Int64.of_int

let problem08 () =
    let open List in
    let product es = List.reduce Int64.mul es in
    let thirteen = mapi (fun i _ ->  product (take 13 (drop i p8_digits ))) p8_digits in
    Printf.sprintf "%Li" (max thirteen)


(*
 * Problem 9: Special Pythagorean triplet
 *
 *
 * A Pythagorean triplet is a set of three natural numbers, a LT b LT c, for which,
 * a^2 + b^2 = c^2
 *
 * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
 *
 * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
 * Find the product a*b*c.
 *)
let problem09 () =
    let answer = ref 0 in
        for c = 1 to 1000 do
            for b = 1 to c do
                for a = 1 to b do
                    if a*a + b*b = c*c && a + b + c = 1000 then answer := a * b * c
                done
            done
        done;
    string_of_int (!answer)


(*
 * Problem 10: Summation of primes
 *
 * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
 * Find the sum of all the primes below two million.
 *)
 let problem10 () =
    let open LazyList in
    take_while (fun x -> x < 2000000L) primes
    |> fold_left Int64.add 0L
    |> Printf.sprintf "%Li"

(* solve = toInteger $ sum (takeWhile (<2000000) primes) *)








